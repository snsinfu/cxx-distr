// Copyright snsinfu 2020.
// Distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef INCLUDED_SNSINFU_DISCRETE_DISTRIBUTION_HPP
#define INCLUDED_SNSINFU_DISCRETE_DISTRIBUTION_HPP

// This is a single header-only library for C++11 and later, providing:
//
// - class cxx::discrete_weights
//   Holds probability weights of a disctete distribution.
//
// - class cxx::discrete_distribution
//   A random number distribution of integers with given weights. This class
//   allows efficient modification of the weights.
//
// See: https://github.com/snsinfu/cxx-distr/

#include <cassert>
#include <cstddef>
#include <initializer_list>
#include <istream>
#include <ostream>
#include <random>
#include <vector>


#ifdef DISTR_DEBUG
#  define DISTR_ASSERT(pred) assert(pred)
#else
#  define DISTR_ASSERT(pred)
#endif


namespace cxx
{
    // WEIGHT TREE -----------------------------------------------------------

    namespace distr_detail
    {
        using std::size_t;


        /*
         * A binary sum tree for storing weight values along with their sums.
         */
        class weight_tree
        {
        public:

            /*
             * Constructs an empty weight tree.
             *
             * The resulting object is only safe for copy and move assignment.
             */
            weight_tree() = default;


            /*
             * Constructs a weight tree from given weights.
             *
             * Params:
             *   weights = Weight values of elements.
             *
             * Time complexity:
             *   O(N) where N is the number of elements (= `weights.size()`).
             */
            explicit
            weight_tree(std::vector<double> const& weights)
            {
                // We construct a complete binary tree in which the leaves
                // contain the weights and internal nodes contain the sums of
                // the weights of children.

                // Determine the number of leaves.
                size_t leaves = 1;

                for (;;) {
                    if (leaves >= weights.size()) {
                        break;
                    }
                    leaves *= 2;
                }

                // We store the binary tree in an array just like commonly
                // done in binary heaps.
                _sumtree.resize(leaves * 2 - 1);
                _leaves = leaves;
                _elements = weights.size();
                DISTR_ASSERT(_leaves >= _elements);

                // Fill the leaves.
                for (size_t i = 0; i < _elements; i++) {
                    _sumtree[_leaves + i - 1] = weights[i];
                }

                // Then, fill internal nodes from leaves to the root. Recall
                // that each node contains the sum of the weights of its
                // children.
                for (size_t layer = 1; ; layer++) {
                    auto const layer_size = leaves >> layer;
                    if (layer_size == 0) {
                        break;
                    }

                    auto const start = layer_size - 1;
                    auto const end = start + layer_size;

                    DISTR_ASSERT(end < _leaves);
                    DISTR_ASSERT(start < end);

                    for (size_t node = start; node < end; node++) {
                        auto const lchild = 2 * node + 1;
                        auto const rchild = 2 * node + 2;
                        _sumtree[node] = _sumtree[lchild] + _sumtree[rchild];
                    }
                }
            }


            /*
             * Updates the weight of i-th element, propagating the change to
             * internal and root nodes.
             *
             * Behavior is undefined if `i` is out of range or `weight` is
             * negative or not finite. It is also undefined that the sum of
             * weights overflow due to the update.
             *
             * Params:
             *   i      = Index of the element to update weight.
             *   weight = New weight value.
             *
             * Time complexity:
             *   O(log N) where N is the number of elements.
             */
            void
            update(size_t i, double weight)
            {
                DISTR_ASSERT(i < _elements);
                DISTR_ASSERT(weight >= 0);

                size_t node = _leaves + i - 1;
                _sumtree[node] = weight;

                do {
                    node = (node - 1) / 2;
                    auto const lchild = 2 * node + 1;
                    auto const rchild = 2 * node + 2;
                    _sumtree[node] = _sumtree[lchild] + _sumtree[rchild];
                } while (node > 0);
            }


            /*
             * Gets a pointer to the array containing weight values.
             */
            double const*
            data() const
            {
                return _sumtree.data() + _leaves - 1;
            }


            /*
             * Gets the number of elements.
             */
            size_t
            size() const noexcept
            {
                return _elements;
            }


            /*
             * Gets the total weight.
             *
             * Returns:
             *   The sum of the weight values of all the elements stored.
             *
             * Time complexity: O(1).
             */
            double
            sum() const noexcept
            {
                return _sumtree[0];
            }


            /*
             * Finds the element whose cumulative weight range covers given
             * probe value.
             *
             * Returns:
             *   The index of the found element.
             *
             * Time complexity:
             *   O(log N) where N is the number of elements.
             */
            size_t
            find(double probe) const
            {
                size_t node = 0;

                for (;;) {
                    auto const lchild = 2 * node + 1;
                    auto const rchild = 2 * node + 2;

                    if (lchild >= _sumtree.size()) {
                        break;
                    }

                    if (probe < _sumtree[lchild]) {
                        node = lchild;
                    } else {
                        probe -= _sumtree[lchild];
                        node = rchild;
                    }
                }

                DISTR_ASSERT(node >= _leaves - 1);
                DISTR_ASSERT(node < _sumtree.size());
                size_t index = node - (_leaves - 1);

                // Search may overshoot due to numerical errors.
                if (index >= _elements) {
                    index = _elements - 1;
                }

                return index;
            }


        private:
            std::vector<double> _sumtree;
            size_t _leaves = 0;
            size_t _elements = 0;
        };


        /*
         * Returns true if two weight trees hold exactly the same weights.
         */
        inline bool
        operator==(
            distr_detail::weight_tree const& w1,
            distr_detail::weight_tree const& w2
        )
        {
            if (w1.size() != w2.size()) {
                return false;
            }

            auto const size = w1.size();
            auto const weights1 = w1.data();
            auto const weights2 = w2.data();

            for (size_t i = 0; i < size; i++) {
                if (weights1[i] != weights2[i]) {
                    return false;
                }
            }

            return true;
        }


        /*
         * Returns true if two weight trees hold weights that differ in at
         * least one element.
         */
        inline bool
        operator!=(
            distr_detail::weight_tree const& w1,
            distr_detail::weight_tree const& w2
        )
        {
            return !(w1 == w2);
        }
    }


    // WEIGHTS ---------------------------------------------------------------

    /*
     * Class holding parameter set of `discrete_distribution`, namely, the
     * probability weights of discrete events.
     */
    class discrete_weights
    {
    public:

        /*
         * Default constructor creates an empty object.
         */
        discrete_weights() = default;


        /*
         * Sets weight values from a vector.
         *
         * Params:
         *   weights = Vector of weight values. The weights must be non-negative
         *             finite numbers.
         */
        explicit
        discrete_weights(std::vector<double> const& weights)
            : _weights{weights}
        {
        }


        /*
         * Sets weight values from an initializer list.
         *
         * Params:
         *   weights = Weight values. The weights must be non-negative finite
         *             numbers.
         */
        discrete_weights(std::initializer_list<double> const& weights)
            : _weights{std::vector<double>(weights)}
        {
        }


        /*
         * Returns the sum of the weights. The time complexity of this
         * function is constant.
         */
        double
        sum() const
        {
            return _weights.sum();
        }


        /*
         * Returns a newly allocated vector containing weight values.
         */
        std::vector<double>
        weights() const
        {
            return std::vector<double>(
                _weights.data(), _weights.data() + _weights.size()
            );
        }


        // Internal API.
        distr_detail::weight_tree&
        weight_tree() noexcept
        {
            return _weights;
        }


        // Internal API.
        distr_detail::weight_tree const&
        weight_tree() const noexcept
        {
            return _weights;
        }


    private:
        distr_detail::weight_tree _weights;
    };


    inline bool
    operator==(
        cxx::discrete_weights const& dw1, cxx::discrete_weights const& dw2
    )
    {
        return dw1.weight_tree() == dw2.weight_tree();
    }


    inline bool
    operator!=(
        cxx::discrete_weights const& dw1, cxx::discrete_weights const& dw2
    )
    {
        return !(dw1 == dw2);
    }


    template<typename Char, typename Tr>
    std::basic_istream<Char, Tr>&
    operator>>(
        std::basic_istream<Char, Tr>& is, cxx::discrete_weights& dw
    )
    {
        using sentry_type = typename std::basic_istream<Char, Tr>::sentry;

        if (sentry_type sentry{is}) {
            std::size_t size;
            if (!(is >> size)) {
                return is;
            }

            std::vector<double> weights(size);
            for (std::size_t i = 0; i < size; i++) {
                if (!(is >> weights[i])) {
                    return is;
                }
            }

            dw = cxx::discrete_weights(weights);
        }

        return is;
    }


    template<typename Char, typename Tr>
    std::basic_ostream<Char, Tr>&
    operator<<(
        std::basic_ostream<Char, Tr>& os, cxx::discrete_weights const& dw
    )
    {
        using sentry_type = typename std::basic_ostream<Char, Tr>::sentry;

        if (sentry_type sentry{os}) {
            auto const& weights = dw.weight_tree();
            auto const size = weights.size();
            auto const values = weights.data();

            os << size;

            for (std::size_t i = 0; i < size; i++) {
                os << os.widen(' ');
                os << values[i];
            }
        }

        return os;
    }


    // DISTRIBUTION ----------------------------------------------------------

    /*
     * Distribution of random integers with given weights.
     */
    class discrete_distribution
    {
    public:

        /*
         * Type of generated integer.
         */
        using result_type = std::size_t;


        /*
         * Class holding distribution parameter set, namely, the weights.
         */
        class param_type : public cxx::discrete_weights
        {
        public:
            using distribution_type = cxx::discrete_distribution;

            using cxx::discrete_weights::discrete_weights;
        };


        discrete_distribution() = default;


        /*
         * Creates a discrete distribution over `[0, N)` with given weights
         * where `N = weights.size()`.
         *
         * Params:
         *   weights = Vector of weight values. The weights must be non-negative
         *             finite numbers.
         */
        explicit
        discrete_distribution(std::vector<double> const& weights)
            : _param{weights}
        {
        }


        /*
         * Creates a discrete distribution with given weights.
         *
         * Params:
         *   weights = Weight values. The weights must be non-negative finite
         *             numbers.
         */
        discrete_distribution(std::initializer_list<double> const& weights)
            : _param{weights}
        {
        }


        /*
         * Creates a discrete distribution with given parameter set.
         *
         * Params:
         *   param = A `cxx::discrete_weights` object.
         */
        explicit
        discrete_distribution(param_type const& param)
            : _param{param}
        {
        }


        /*
         * Resets the distribution state. This function does nothing.
         */
        void
        reset()
        {
        }


        /*
         * Returns the parameter set of this distribution.
         */
        param_type const&
        param() const noexcept
        {
            return _param;
        }


        /*
         * Reconfigures the distribution using given parameter set.
         */
        void
        param(param_type const& new_param)
        {
            _param = new_param;
        }


        /*
         * Returns the minimum possible integer generated from this
         * distribution, namely, zero.
         */
        result_type
        min() const
        {
            return 0;
        }


        /*
         * Returns the maximum possible integer generated from this
         * distribution.
         */
        result_type
        max() const
        {
            return _param.weight_tree().size() - 1;
        }


        /*
         * Returns the sum of the weights.
         *
         * Time complexity:
         *   O(1).
         */
        double
        sum() const
        {
            return _param.sum();
        }


        /*
         * Returns a newly allocated vector containing the weight values.
         */
        std::vector<double>
        weights() const
        {
            return _param.weights();
        }


        /*
         * Updates the weight of the number `i`.
         *
         * Params:
         *   i      = Number to change weight. Must be in the valid interval
         *            `[min(), max()]`.
         *   weight = New weight. Must be non-negative finite number.
         *
         * Time complexity:
         *   O(log N) where N is the upper bound.
         */
        void
        update(result_type i, double weight)
        {
            return _param.weight_tree().update(i, weight);
        }


        /*
         * Generates an integer randomly from the weighted distribution.
         *
         * Params:
         *   random = Random number generator to use.
         *
         * Time complexity:
         *   O(log N) where N is the upper bound.
         */
        template<typename RNG>
        result_type
        operator()(RNG& random) const
        {
            auto const& weights = _param.weight_tree();
            std::uniform_real_distribution<double> uniform{0.0, weights.sum()};
            return weights.find(uniform(random));
        }


    private:
        param_type _param;
    };


    inline bool
    operator==(
        cxx::discrete_distribution const& d1,
        cxx::discrete_distribution const& d2
    )
    {
        return d1.param() == d2.param();
    }


    inline bool
    operator!=(
        cxx::discrete_distribution const& d1,
        cxx::discrete_distribution const& d2
    )
    {
        return !(d1 == d2);
    }


    template<typename Char, typename Tr>
    std::basic_istream<Char, Tr>&
    operator>>(
        std::basic_istream<Char, Tr>& is,
        cxx::discrete_distribution& distr
    )
    {
        using param_type = cxx::discrete_distribution::param_type;
        param_type param;
        is >> param;
        distr.param(param);
        return is;
    }


    template<typename Char, typename Tr>
    std::basic_ostream<Char, Tr>&
    operator<<(
        std::basic_ostream<Char, Tr>& os,
        cxx::discrete_distribution const& distr
    )
    {
        return os << distr.param();
    }
}

#undef DISTR_ASSERT

#endif
