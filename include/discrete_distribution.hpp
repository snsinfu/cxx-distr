// Copyright snsinfu 2020.
// Distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef INCLUDED_SNSINFU_DISCRETE_DISTRIBUTION_HPP
#define INCLUDED_SNSINFU_DISCRETE_DISTRIBUTION_HPP

// This is a single header-only library for C++11 and later, providing:
//
// - class cxx::discrete_weights
//   Holds probability weights of a disctete distribution.
//
// - class cxx::discrete_distribution
//   A random number distribution of integers with given weights. This class
//   allows efficient modification of the weights.
//
// See: https://github.com/snsinfu/cxx-distr/

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <initializer_list>
#include <istream>
#include <ostream>
#include <random>
#include <vector>


#ifdef DISTR_DEBUG
#  define DISTR_ASSERT(pred) assert(pred)
#else
#  define DISTR_ASSERT(pred)
#endif


namespace cxx
{
    // WEIGHTS ---------------------------------------------------------------

    /*
     * Class holding the weights of a discrete distribution. It allows
     * efficient reweighting and searching.
     */
    class discrete_weights
    {
    public:

        using pointer = double const*;
        using iterator = double const*;


        /*
         * Default constructor creates an empty object.
         */
        discrete_weights() = default;


        /*
         * Sets weight values from a vector.
         *
         * Params:
         *   weights = Weight values. The weights must be non-negative finite
         *             numbers.
         *
         * Time complexity:
         *   O(N) where N is the number of events (= `weights.size()`).
         */
        explicit
        discrete_weights(std::vector<double> const& weights)
        {
            // Construct a complete binary tree in which the leaves contain
            // the weights and internal nodes contain the sums of the weights
            // of children.

            // Determine the number of leaves.
            std::size_t leaves = 1;

            for (;;) {
                if (leaves >= weights.size()) {
                    break;
                }
                leaves *= 2;
            }

            // We store the binary tree as an array using the usual scheme:
            //
            //   root = 0 ,
            //   parent(node) = (node - 1) / 2 .
            //
            _sumtree.resize(leaves * 2 - 1);
            _leaves = leaves;
            _events = weights.size();
            DISTR_ASSERT(_leaves >= _events);

            // Fill the leaves.
            for (std::size_t i = 0; i < _events; i++) {
                _sumtree[_leaves + i - 1] = weights[i];
            }

            // Then, fill internal nodes from leaves to the root. Recall
            // that each node contains the sum of the weights of its
            // children.
            for (std::size_t layer = 1; ; layer++) {
                auto const layer_size = leaves >> layer;
                if (layer_size == 0) {
                    break;
                }

                auto const start = layer_size - 1;
                auto const end = start + layer_size;

                DISTR_ASSERT(end < _leaves);
                DISTR_ASSERT(start < end);

                for (std::size_t node = start; node < end; node++) {
                    auto const lchild = 2 * node + 1;
                    auto const rchild = 2 * node + 2;
                    _sumtree[node] = _sumtree[lchild] + _sumtree[rchild];
                }
            }
        }


        /*
         * Sets weight values from an initializer list.
         *
         * Params:
         *   weights = Weight values. The weights must be non-negative finite
         *             numbers.
         */
        discrete_weights(std::initializer_list<double> const& weights)
            : discrete_weights{std::vector<double>{weights}}
        {
        }


        /*
         * Returns the number of events.
         */
        inline std::size_t
        size() const noexcept
        {
            return _events;
        }


        /*
         * Returns a pointer to the array containing weight values.
         */
        inline pointer
        data() const noexcept
        {
            return _sumtree.data() + _leaves - 1;
        }


        /*
         * Returns an iterator pointing to the beginning of the array
         * containing weight values.
         */
        inline iterator
        begin() const noexcept
        {
            return data();
        }


        /*
         * Returns an iterator pointing to the past the end of the array
         * containing weight values.
         */
        inline iterator
        end() const noexcept
        {
            return data() + size();
        }


        /*
         * Returns the weight of the i-th event.
         */
        inline double
        operator[](std::size_t i) const
        {
            return *(data() + i);
        }


        /*
         * Returns the sum of the weights.
         *
         * Time complexity:
         *   O(1).
         */
        inline double
        sum() const
        {
            return _sumtree[0];
        }


        /*
         * Updates the weight of the i-th event.
         *
         * Behavior is undefined if `i` is out of range or `weight` is
         * negative or not finite. It is also undefined that the sum of
         * weights overflow due to the update.
         *
         * Params:
         *   i      = Index of the event to update weight.
         *   weight = New weight value.
         *
         * Time complexity:
         *   O(log N) where N is the number of events.
         */
        void
        update(std::size_t i, double weight)
        {
            DISTR_ASSERT(i < _events);
            DISTR_ASSERT(weight >= 0);

            auto node = _leaves + i - 1;
            _sumtree[node] = weight;

            do {
                node = (node - 1) / 2;
                auto const lchild = 2 * node + 1;
                auto const rchild = 2 * node + 2;
                _sumtree[node] = _sumtree[lchild] + _sumtree[rchild];
            } while (node > 0);
        }


        /*
         * Finds the event whose cumulative weight interval covers given probe
         * value.
         *
         * Let `w[i]` be the weight of the i-th event, and let `s[i]` be the
         * cumulative sum until the i-th event. That is,
         *
         *    s[0] = 0 ,
         *    s[i] = w[0] + ... + w[i-1] .
         *
         * Then, this function finds the event i such that
         *
         *    s[i] <= probe < s[i+1] .
         *
         * Params:
         *   probe = Probe weight used to find an event.
         *
         * Returns:
         *   The index of the event found.
         *
         * Time complexity:
         *   O(log N) where N is the number of events.
         */
        std::size_t
        find(double probe) const
        {
            std::size_t node = 0;

            for (;;) {
                auto const lchild = 2 * node + 1;
                auto const rchild = 2 * node + 2;

                if (lchild >= _sumtree.size()) {
                    break;
                }

                if (probe < _sumtree[lchild]) {
                    node = lchild;
                } else {
                    probe -= _sumtree[lchild];
                    node = rchild;
                }
            }

            DISTR_ASSERT(node >= _leaves - 1);
            DISTR_ASSERT(node < _sumtree.size());
            auto index = node - (_leaves - 1);

            // Search may overshoot due to numerical errors.
            if (index >= _events) {
                index = _events - 1;
            }

            return index;
        }
    private:
        std::vector<double> _sumtree;
        std::size_t _leaves = 0;
        std::size_t _events = 0;
    };


    inline bool
    operator==(cxx::discrete_weights const& w1, cxx::discrete_weights const& w2)
    {
        if (w1.size() != w2.size()) {
            return false;
        }
        return std::equal(w1.begin(), w1.end(), w2.begin());
    }


    inline bool
    operator!=(cxx::discrete_weights const& w1, cxx::discrete_weights const& w2)
    {
        return !(w1 == w2);
    }


    template<typename Char, typename Tr>
    std::basic_istream<Char, Tr>&
    operator>>(
        std::basic_istream<Char, Tr>& is,
        cxx::discrete_weights& weights
    )
    {
        using sentry_type = typename std::basic_istream<Char, Tr>::sentry;

        if (sentry_type sentry{is}) {
            std::size_t size;
            if (!(is >> size)) {
                return is;
            }

            std::vector<double> values(size);
            for (auto& value : values) {
                if (!(is >> value)) {
                    return is;
                }
            }

            weights = cxx::discrete_weights{values};
        }

        return is;
    }


    template<typename Char, typename Tr>
    std::basic_ostream<Char, Tr>&
    operator<<(
        std::basic_ostream<Char, Tr>& os,
        cxx::discrete_weights const& weights
    )
    {
        using sentry_type = typename std::basic_ostream<Char, Tr>::sentry;

        if (sentry_type sentry{os}) {
            os << weights.size();

            auto const sep = os.widen(' ');

            for (auto weight : weights) {
                os << sep;
                os << weight;
            }
        }

        return os;
    }


    // DISTRIBUTION ----------------------------------------------------------

    /*
     * Distribution of random integers with given weights.
     */
    class discrete_distribution
    {
    public:

        /*
         * Type of generated integer.
         */
        using result_type = std::size_t;


        /*
         * Class holding distribution parameter set, namely, the weights.
         */
        class param_type : public cxx::discrete_weights
        {
        public:
            using distribution_type = cxx::discrete_distribution;

            using cxx::discrete_weights::discrete_weights;
        };


        /*
         * Default constructor creates an empty distribution.
         */
        discrete_distribution() = default;


        /*
         * Creates a discrete distribution over `[0, N)` with given weights
         * where `N = weights.size()`.
         *
         * Params:
         *   weights = Weight values. The weights must be non-negative finite
         *             numbers.
         */
        explicit
        discrete_distribution(std::vector<double> const& weights)
            : _weights{weights}
        {
        }


        /*
         * Creates a discrete distribution with given weights.
         *
         * Params:
         *   weights = Weight values. The weights must be non-negative finite
         *             numbers.
         */
        discrete_distribution(std::initializer_list<double> const& weights)
            : _weights{weights}
        {
        }


        /*
         * Creates a discrete distribution with given parameter set.
         *
         * Params:
         *   param = A `cxx::discrete_weights` object.
         */
        explicit
        discrete_distribution(param_type const& param)
            : _weights{param}
        {
        }


        /*
         * Resets the distribution state. This function does nothing.
         */
        void
        reset()
        {
        }


        /*
         * Returns the parameter set of this distribution. It is convertible
         * to `cxx::discrete_weights`.
         */
        param_type const&
        param() const noexcept
        {
            return _weights;
        }


        /*
         * Reconfigures the distribution using given parameter set. It is
         * convertible from `cxx::discrete_weights`.
         */
        void
        param(param_type const& new_param)
        {
            _weights = new_param;
        }


        /*
         * Returns the minimum possible integer generated from this
         * distribution, namely, zero.
         */
        result_type
        min() const
        {
            return 0;
        }


        /*
         * Returns the maximum possible integer generated from this
         * distribution.
         */
        result_type
        max() const
        {
            return _weights.size() - 1;
        }


        /*
         * Returns the sum of the weights.
         *
         * Time complexity:
         *   O(1).
         */
        double
        sum() const
        {
            return _weights.sum();
        }


        /*
         * Updates the weight of the number `i`.
         *
         * Params:
         *   i      = Number to change weight. Must be in the valid interval
         *            `[min(), max()]`.
         *   weight = New weight. Must be non-negative finite number.
         *
         * Time complexity:
         *   O(log N) where N is the upper bound.
         */
        void
        update(result_type i, double weight)
        {
            return _weights.update(i, weight);
        }


        /*
         * Generates an integer randomly from the weighted distribution.
         *
         * Params:
         *   random = Random number generator to use.
         *
         * Time complexity:
         *   O(log N) where N is the upper bound.
         */
        template<typename RNG>
        result_type
        operator()(RNG& random) const
        {
            std::uniform_real_distribution<double> uniform{0.0, _weights.sum()};
            return _weights.find(uniform(random));
        }


    private:
        param_type _weights;
    };


    inline bool
    operator==(
        cxx::discrete_distribution const& d1,
        cxx::discrete_distribution const& d2
    )
    {
        return d1.param() == d2.param();
    }


    inline bool
    operator!=(
        cxx::discrete_distribution const& d1,
        cxx::discrete_distribution const& d2
    )
    {
        return !(d1 == d2);
    }


    template<typename Char, typename Tr>
    std::basic_istream<Char, Tr>&
    operator>>(
        std::basic_istream<Char, Tr>& is,
        cxx::discrete_distribution& distr
    )
    {
        using param_type = cxx::discrete_distribution::param_type;
        param_type param;
        is >> param;
        distr.param(param);
        return is;
    }


    template<typename Char, typename Tr>
    std::basic_ostream<Char, Tr>&
    operator<<(
        std::basic_ostream<Char, Tr>& os,
        cxx::discrete_distribution const& distr
    )
    {
        return os << distr.param();
    }
}

#undef DISTR_ASSERT

#endif
